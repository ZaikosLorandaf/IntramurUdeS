CREATE SCHEMA IF NOT EXISTS intramurudes;
SET search_path = intramurudes;

CREATE TABLE sport(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(100) NOT NULL,
                    nb_team_match INT NOT NULL DEFAULT 2,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    UNIQUE(name)
);

CREATE TABLE league(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(127) NOT NULL,
                    begin_date DATE,
                    end_date DATE,
                    done BOOL DEFAULT false,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_sport INT NOT NULL,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_sport) REFERENCES sport(id)
);

CREATE TABLE team(
                     id INT GENERATED BY DEFAULT AS IDENTITY,
                     name VARCHAR(127) NOT NULL,
                     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                     id_league INT NOT NULL,
                     archive BOOLEAN DEFAULT FALSE,
                     PRIMARY KEY(id),
                     FOREIGN KEY(id_league) REFERENCES league(id)
);

CREATE TABLE player(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(127),
                    last_name VARCHAR(127),
                    number INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_team INT NOT NULL,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_team) REFERENCES team(id)
);


CREATE TABLE season(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    season_year INT NOT NULL,
                    time_precision VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id)
);

CREATE TABLE match_(
                       id INT GENERATED BY DEFAULT AS IDENTITY,
                       date_match DATE,
                       begin_time TIME,
                       end_time TIME,
                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                       id_league INT,
                       id_season INT DEFAULT 11 NOT NULL,
                       archive BOOLEAN DEFAULT FALSE,
                       PRIMARY KEY(id),
                       FOREIGN KEY(id_league) REFERENCES league(id),
                       FOREIGN KEY(id_season) REFERENCES season(id)
);

CREATE TABLE stat_statement(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    statement TEXT UNIQUE,
                    acronym VARCHAR(4),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id)
);

CREATE TABLE team_stat(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    value_ VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_season INT,
                    id_match INT,
                    id_stat_statement INT NOT NULL,
                    id_team INT NOT NULL,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES stat_statement(id),
                    FOREIGN KEY(id_team) REFERENCES team(id),
                    FOREIGN KEY(id_season) REFERENCES season(id),
                    FOREIGN KEY(id_match) REFERENCES match_(id)
);

CREATE TABLE player_stat(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    value_ VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_match INT,
                    id_stat_statement INT NOT NULL,
                    id_season INT,
                    id_player INT NOT NULL,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_match) REFERENCES match_(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES stat_statement(id),
                    FOREIGN KEY(id_season) REFERENCES season(id),
                    FOREIGN KEY(id_player) REFERENCES player(id)
);

CREATE TABLE role(
                     id INT GENERATED BY DEFAULT AS IDENTITY,
                     role_name VARCHAR(127),
                     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                     archive BOOLEAN DEFAULT FALSE,
                     PRIMARY KEY(id)
);

CREATE TABLE user_(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    username VARCHAR(127) NOT NULL,
                    password VARCHAR(127) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id),
                    UNIQUE(username)
);

CREATE TABLE log(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    text TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id)
);

CREATE TABLE match_team(
                    id_team INT,
                    id_match INT,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id_team, id_match),
                    FOREIGN KEY(id_team) REFERENCES team(id),
                    FOREIGN KEY(id_match) REFERENCES match_(id)
);

CREATE TABLE league_season(
                    id_league INT,
                    id_season INT,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id_league, id_season),
                    FOREIGN KEY(id_league) REFERENCES league(id),
                    FOREIGN KEY(id_season) REFERENCES season(id)
);

CREATE TABLE role_user(
                    id_role INT,
                    id_user INT,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id_role, id_user),
                    FOREIGN KEY(id_role) REFERENCES role(id),
                    FOREIGN KEY(id_user) REFERENCES user_(id)
);

CREATE TABLE stat_statement_sport(
                    id_sport INT,
                    id_stat_statement INT,
                    archive BOOLEAN DEFAULT FALSE,
                    PRIMARY KEY(id_sport, id_stat_statement),
                    FOREIGN KEY(id_sport) REFERENCES sport(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES stat_statement(id)
);


CREATE OR REPLACE VIEW v_match_teams AS
SELECT m.id AS id_match, m.date_match, m.begin_time, m.end_time,
       COUNT(mt.id_team) AS nb_teams,
       COALESCE(NULLIF(
                                ARRAY_AGG(mt.id_team) FILTER (WHERE mt.id_team IS NOT NULL),
                                '{}'
                ),
                ARRAY[-1]
       ) AS list_teams,
       m.archive AS archive_match
FROM match_ m
         LEFT JOIN intramurudes.match_team mt ON m.id = mt.id_match
GROUP BY m.id, m.date_match, m.begin_time, m.end_time;


CREATE OR REPLACE VIEW v_player_team_league_sport
AS
SELECT p.id AS id_player, p.name AS player_name, p.last_name, p.number,
       t.id AS id_team, t.name AS team_name,
       l.id AS id_league, l.name AS league_name, l.begin_date, l.end_date,
       s.id AS id_sport, s.name AS sport_name, s.nb_team_match,
       p.archive AS archive_player
FROM intramurudes.player p
         LEFT JOIN intramurudes.team t ON t.id = p.id_team
         LEFT JOIN intramurudes.league l ON l.id = t.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport;


CREATE OR REPLACE VIEW v_team_league_sport
AS
SELECT t.id AS id_team, t.name AS team_name,
       l.id AS id_league, l.name AS league_name, l.begin_date, l.end_date,
       s.id AS id_sport, s.name AS sport_name, s.nb_team_match,
       s.archive AS archive_sport
FROM intramurudes.team t
         LEFT JOIN intramurudes.league l ON l.id = t.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport;


CREATE OR REPLACE VIEW v_league_sport
AS
SELECT l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date, l.done,
       s.id AS id_sport, s.name AS name_soprt, s.nb_team_match,
       l.archive AS archive_league
FROM league AS l
         LEFT JOIN intramurudes.sport s ON l.id_sport = s.id;


CREATE OR REPLACE VIEW v_match_league_sport
AS
SELECT m.id AS match_id, m.date_match, m.begin_time, m.end_time,
       l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date, l.done,
       s.id AS id_sport, s.name AS name_sport, s.nb_team_match,
       COALESCE(NULLIF(
                                ARRAY_AGG(mt.id_team) FILTER (WHERE mt.id_team IS NOT NULL),
                                '{}'
                ),
                ARRAY[-1]
       ) AS list_teams,

       m.id_season AS id_season, m.archive AS archive_match
FROM intramurudes.match_ m
         LEFT JOIN intramurudes.league l ON l.id = m.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport
         LEFT JOIN intramurudes.match_team mt ON mt.id_match = m.id
GROUP BY m.id, m.date_match, m.id, m.begin_time, m.end_time, l.id, l.name, l.begin_date, l.end_date, l.done, s.id, s.name, s.nb_team_match
ORDER BY s.name, l.name, l.begin_date;

CREATE OR REPLACE VIEW v_league
AS
SELECT l.id as id,
       l.name as name,
       l.begin_date as begin_date,
       l.end_date as end_date,
       l.done,
       l.id_sport,
       COALESCE(NULLIF(
                ARRAY_AGG(ls.id_season) FILTER (WHERE ls.id_season IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS id_seasons,
       l.archive AS archive_league
FROM intramurudes.league l
         LEFT JOIN intramurudes.league_season ls ON l.id = ls.id_league
GROUP BY l.id, l.name, l.begin_date, l.end_date, l.done, l.id_sport;


CREATE OR REPLACE VIEW v_stat_statement
AS
SELECT s.id as id,
       s.statement as statement,
       s.acronym as acronym,
       COALESCE(NULLIF(
                ARRAY_AGG(sss.id_sport) FILTER (WHERE sss.id_sport IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS id_sports
FROM intramurudes.stat_statement s
         LEFT JOIN intramurudes.stat_statement_sport sss ON s.id = sss.id_stat_statement
GROUP BY s.id, s.statement, s.acronym;

CREATE OR REPLACE VIEW v_player_stat
AS
SELECT ps.id AS id,
       ps.value_ AS value,
       CASE
           WHEN ps.id_match IS NULL THEN -1
           ELSE ps.id_match END
           AS id_match,
       ps.id_stat_statement AS id_stat_statement,
       CASE
           WHEN ps.id_season IS NULL THEN -1
           ELSE ps.id_season END
           AS id_season,
       ps.id_player AS id_player,
       CASE
           WHEN m.id_league IS NULL THEN -1
           ELSE m.id_league END AS id_league,
       vptls.id_team AS id_team,
       vptls.id_league AS id_league_player,
       vptls.id_sport AS id_sport
FROM intramurudes.player_stat ps
         LEFT JOIN match_ m ON m.id = ps.id_match
         LEFT JOIN intramurudes.v_player_team_league_sport vptls ON vptls.id_player = ps.id_player;


CREATE OR REPLACE VIEW v_team_stat
AS
SELECT ts.id AS id,
       ts.value_ AS value,
       CASE
           WHEN ts.id_match IS NULL THEN -1
           ELSE ts.id_match END
           AS id_match,
       ts.id_stat_statement AS id_stat_statement,
       CASE
           WHEN ts.id_season IS NULL THEN -1
           ELSE ts.id_season END
           AS id_season,
       CASE
           WHEN m.id_league IS NULL THEN -1
           ELSE m.id_league END AS id_league,
       vtls.id_team AS id_team,
       vtls.id_league AS id_league_team,
       vtls.id_sport AS id_sport
FROM intramurudes.team_stat ts
         LEFT JOIN match_ m ON m.id = ts.id_match
         LEFT JOIN intramurudes.v_team_league_sport vtls ON vtls.id_team = ts.id_team;




ALTER TABLE league ADD CONSTRAINT league_name_sport_id_unique UNIQUE  (name, id_sport);

ALTER TABLE team ADD CONSTRAINT team_name_league_id UNIQUE (name, id_league);

ALTER TABLE player ADD CONSTRAINT player_number_team_id_unique UNIQUE  (number, id_team);

ALTER TABLE season ADD CONSTRAINT season_year_time_precision_unique UNIQUE  (season_year, time_precision);

CREATE OR REPLACE FUNCTION get_season_from_league(id_league_get INT)
    RETURNS SETOF INT
    LANGUAGE SQL
AS $$
SELECT id_season FROM league_season ls
WHERE ls.id_league = id_league_get;
$$;

/**
  Vérifier la légalité de l'ajout du match
 */
CREATE OR REPLACE FUNCTION check_before_insert_match_()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
BEGIN
    IF (new.id_season IS NOT NULL
        AND
        new.id_season IN (SELECT get_season_from_league(new.id_league)))
    THEN
        RETURN new;
    ELSE
        RAISE 'Match is not in a season of the league';
    END IF;
END
$$;


CREATE TRIGGER trg_check_insert_match
    BEFORE INSERT ON match_
    FOR EACH ROW
EXECUTE function check_before_insert_match_();


/**
  Fonction qui donne le nombre de places restantes pour le match
 */
CREATE OR REPLACE FUNCTION get_place_left_match(id_new_match INT)
    RETURNS INT
    LANGUAGE SQL
AS $$
SELECT ((SELECT nb_team_match FROM v_league_sport vls
         WHERE id_league = (SELECT id_league FROM match_
                            WHERE id = id_new_match))
    -
        (SELECT COUNT(id_team) FROM match_team
         WHERE id_match = id_new_match));
$$;

/**
  Trigger pour s'assurer que toutes les équipes d'un match sont dans la même ligue
 */
CREATE OR REPLACE FUNCTION check_team_good_league(id_new_team INT, id_new_match INT)
    RETURNS BOOLEAN
    LANGUAGE SQL
AS $$
SELECT((SELECT m.id_league
        FROM match_ m
        WHERE m.id = id_new_match) IS NULL
    OR
       (SELECT vtls.id_league
        FROM v_team_league_sport vtls
        WHERE vtls.id_team = id_new_team) =
       ((SELECT m.id_league FROM match_ m
         WHERE m.id = id_new_match))
          );
$$;

/**
  Fonction pour vérifier chevauchement match
 */
CREATE OR REPLACE FUNCTION get_match_overlap(id_team_check INT, new_match_id INT)
    RETURNS SETOF INT
    LANGUAGE SQL
AS $$
SELECT id FROM match_ m
                   INNER JOIN intramurudes.match_team mt ON m.id = mt.id_match
WHERE m.date_match = (SELECT date_match FROM match_ WHERE id = new_match_id)
  AND
    (m.begin_time, m.end_time) OVERLAPS ((SELECT m2.begin_time FROM match_ m2 WHERE id = new_match_id),
                                         (SELECT m2.end_time FROM match_ m2 WHERE id = new_match_id))
  AND
    mt.id_team = id_team_check;
$$;

CREATE OR REPLACE FUNCTION check_before_insert_match_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF NOT EXISTS(SELECT get_match_overlap(new.id_team,
                                           new.id_match))
    THEN
        IF ((SELECT get_place_left_match(new.id_match)) > 0)
        THEN
            IF (SELECT check_team_good_league(new.id_team, new.id_match))
            THEN
                RETURN new;
            ELSE
                RAISE 'Team is not in the good league';
            END IF;
        ELSE
            RAISE 'Match is full';
        END IF;
    ELSE
        RAISE 'Match overlaps with another match of the team';
    END IF;
END;
$$;

CREATE TRIGGER trg_check_insert_match_team
    BEFORE INSERT ON match_team
    FOR EACH ROW
EXECUTE function check_before_insert_match_team();


--Fonctions pour insérer dans la vue des stat_statement et faire le lien avec le sport
CREATE OR REPLACE FUNCTION insert_v_stat_statement()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
DECLARE
    id_sport_add int;
    id_stat int;
BEGIN
    IF (new.statement NOT IN (SELECT statement FROM v_stat_statement))
    THEN
        INSERT INTO stat_statement(statement, acronym)
        VALUES (new.statement, new.acronym);
    END IF;
    id_stat = (SELECT id FROM stat_statement
               WHERE statement = new.statement);
    FOREACH id_sport_add IN ARRAY new.id_sports
        LOOP
            IF(NOT id_sport_add = ANY (SELECT unnest(id_sports) FROM v_stat_statement
                                       WHERE id = id_stat))
            THEN
                INSERT INTO stat_statement_sport(id_sport, id_stat_statement)
                VALUES (id_sport_add, id_stat);
            END IF;

        END LOOP;
    RETURN new;
END
$$;


CREATE TRIGGER trg_insert_v_stat_statement
    INSTEAD OF INSERT ON v_stat_statement
    FOR EACH ROW
EXECUTE function insert_v_stat_statement();




--Méthode pour mettre la saison selon le match de la stat s'il y a un match
CREATE OR REPLACE FUNCTION create_stat()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
BEGIN
    --Mettre la bonne saison
    IF new.id_match IS NOT NULL
    THEN
        new.id_season = (SELECT id_season FROM intramurudes.match_
                         WHERE id = new.id_match);
    END IF;
    RETURN new;
END
$$;

CREATE TRIGGER trg_create_stat
    BEFORE INSERT ON player_stat
    FOR EACH ROW
EXECUTE function create_stat();

CREATE TRIGGER trg_create_stat
    BEFORE INSERT ON team_stat
    FOR EACH ROW
EXECUTE function create_stat();




--Trigger pour les deletes
CREATE OR REPLACE FUNCTION instead_delete_sport()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE sport s
    SET archive = TRUE
    WHERE s.id = old.id AND archive = FALSE;

    DELETE FROM league
    WHERE id_sport = old.id;

    DELETE FROM stat_statement_sport
    WHERE id_sport = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_sport
    BEFORE DELETE ON sport
    FOR EACH ROW
EXECUTE function instead_delete_sport();


CREATE OR REPLACE FUNCTION instead_delete_league()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE league l
    SET archive = TRUE
    WHERE l.id = old.id AND archive = FALSE;

    DELETE FROM team
    WHERE id_league = old.id;

    DELETE FROM league_season
    WHERE id_league = old.id;

    DELETE FROM match_
    WHERE id_league = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_league
    BEFORE DELETE ON league
    FOR EACH ROW
EXECUTE function instead_delete_league();



CREATE OR REPLACE FUNCTION instead_delete_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE team t
    SET archive = TRUE
    WHERE t.id = old.id AND archive = FALSE;

    DELETE FROM player p
    WHERE p.id_team = old.id;

    DELETE FROM match_team
    WHERE id_team = old.id;

    DELETE FROM team_stat
    WHERE id_team = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_team
    BEFORE DELETE ON team
    FOR EACH ROW
EXECUTE function instead_delete_team();



CREATE OR REPLACE FUNCTION instead_delete_player()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE player p
    SET archive = TRUE
    WHERE p.id = old.id AND archive = FALSE;

    DELETE FROM player_stat ps
    WHERE ps.id_player = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_player
    BEFORE DELETE ON player
    FOR EACH ROW
EXECUTE function instead_delete_player();



CREATE OR REPLACE FUNCTION instead_delete_league_season()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE league_season ls
    SET archive = TRUE
    WHERE ls.id_league = old.id_league AND ls.id_season = old.id_season AND archive = FALSE;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_league_season
    BEFORE DELETE ON league_season
    FOR EACH ROW
EXECUTE function instead_delete_league_season();



CREATE OR REPLACE FUNCTION instead_delete_match()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE match_ m
    SET archive = TRUE
    WHERE m.id = old.id AND archive = FALSE;

    DELETE FROM match_team
    WHERE id_match = old.id;

    DELETE FROM player_stat
    WHERE id_match = old.id;

    DELETE FROM team_stat
    WHERE id_match = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_match
    BEFORE DELETE ON match_
    FOR EACH ROW
EXECUTE function instead_delete_match();



CREATE OR REPLACE FUNCTION instead_delete_match_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE match_team mt
    SET archive = TRUE
    WHERE mt.id_match = old.id_match AND mt.id_team = old.id_team AND archive = FALSE;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_match_team
    BEFORE DELETE ON match_team
    FOR EACH ROW
EXECUTE function instead_delete_match_team();


CREATE OR REPLACE FUNCTION instead_delete_player_stat()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    UPDATE player_stat ps
    SET archive = TRUE
    WHERE ps.id = old.id AND archive = FALSE;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_player_stat
    BEFORE DELETE
    ON player_stat
    FOR EACH ROW
EXECUTE FUNCTION instead_delete_player_stat();


CREATE OR REPLACE FUNCTION instead_delete_season()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE season s
    SET archive = TRUE
    WHERE s.id = old.id AND archive = FALSE;

    DELETE FROM player_stat
    WHERE id_season = old.id;

    DELETE FROM team_stat
    WHERE id_season = old.id;

    DELETE FROM league_season
    WHERE id_season = old.id;

    DELETE FROM match_
    WHERE id_season = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_season
    BEFORE DELETE ON season
    FOR EACH ROW
EXECUTE function instead_delete_season();



CREATE OR REPLACE FUNCTION instead_delete_stat_statement()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE stat_statement s
    SET archive = TRUE
    WHERE s.id = old.id AND archive = FALSE;

    DELETE FROM stat_statement_sport
    WHERE id_stat_statement = old.id;

    DELETE FROM team_stat
    WHERE id_stat_statement = old.id;

    DELETE FROM player_stat
    WHERE id_stat_statement = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_stat_statement
    BEFORE DELETE ON stat_statement
    FOR EACH ROW
EXECUTE function instead_delete_stat_statement();



CREATE OR REPLACE FUNCTION instead_delete_stat_statement_sport()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE stat_statement_sport s
    SET archive = TRUE
    WHERE s.id_stat_statement = old.id_stat_statement AND s.id_sport = old.id_sport AND archive = FALSE;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_stat_statement_sport
    BEFORE DELETE ON stat_statement_sport
    FOR EACH ROW
EXECUTE function instead_delete_stat_statement_sport();




CREATE OR REPLACE FUNCTION instead_delete_team_stat()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE team_stat ts
    SET archive = TRUE
    WHERE ts.id = old.id AND archive = FALSE;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_team_stat
    BEFORE DELETE ON team_stat
    FOR EACH ROW
EXECUTE function instead_delete_team_stat();
