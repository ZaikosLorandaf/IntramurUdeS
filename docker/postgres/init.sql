CREATE SCHEMA IF NOT EXISTS intramurudes;
SET search_path = intramurudes;

CREATE TABLE intramurudes.sport(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(100) NOT NULL,
                    nb_team_match INT NOT NULL DEFAULT 2,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    UNIQUE(name, archive)
);

CREATE TABLE intramurudes.league(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(127) NOT NULL,
                    begin_date DATE,
                    end_date DATE,
                    done BOOL DEFAULT false,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_sport INT NOT NULL,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_sport) REFERENCES sport(id),
                    UNIQUE (name, id_sport, archive)
);


CREATE TABLE intramurudes.team(
                     id INT GENERATED BY DEFAULT AS IDENTITY,
                     name VARCHAR(127) NOT NULL,
                     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                     id_league INT NOT NULL,
                     archive TIMESTAMP,
                     PRIMARY KEY(id),
                     FOREIGN KEY(id_league) REFERENCES intramurudes.league(id),
                     UNIQUE (name, id_league, archive)
);

CREATE TABLE intramurudes.player(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    name VARCHAR(127),
                    last_name VARCHAR(127),
                    number INT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_team INT NOT NULL,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_team) REFERENCES team(id),
                    UNIQUE (number, id_team, archive)
);





CREATE TABLE intramurudes.season(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    season_year INT NOT NULL,
                    time_precision VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    UNIQUE (season_year, time_precision, archive)
);



CREATE TABLE intramurudes.match_(
                       id INT GENERATED BY DEFAULT AS IDENTITY,
                       date_match DATE,
                       begin_time TIME,
                       end_time TIME,
                       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                       id_league INT,
                       id_season INT DEFAULT 11 NOT NULL,
                       archive TIMESTAMP,
                       place VARCHAR(127) DEFAULT '--',
                       PRIMARY KEY(id),
                       FOREIGN KEY(id_league) REFERENCES intramurudes.league(id),
                       FOREIGN KEY(id_season) REFERENCES intramurudes.season(id)
);

CREATE TABLE intramurudes.stat_statement(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    statement TEXT,
                    acronym VARCHAR(4),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    UNIQUE (statement, archive)
);

CREATE TABLE intramurudes.team_stat(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    value_ VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_season INT,
                    id_match INT,
                    id_stat_statement INT NOT NULL,
                    id_team INT NOT NULL,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES intramurudes.stat_statement(id),
                    FOREIGN KEY(id_team) REFERENCES intramurudes.team(id),
                    FOREIGN KEY(id_season) REFERENCES intramurudes.season(id),
                    FOREIGN KEY(id_match) REFERENCES intramurudes.match_(id)
);

CREATE TABLE intramurudes.player_stat(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    value_ VARCHAR(127),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    id_match INT,
                    id_stat_statement INT NOT NULL,
                    id_season INT,
                    id_player INT NOT NULL,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    FOREIGN KEY(id_match) REFERENCES intramurudes.match_(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES intramurudes.stat_statement(id),
                    FOREIGN KEY(id_season) REFERENCES intramurudes.season(id),
                    FOREIGN KEY(id_player) REFERENCES intramurudes.player(id)
);

CREATE TABLE intramurudes.role(
                     id INT GENERATED BY DEFAULT AS IDENTITY,
                     role_name VARCHAR(127),
                     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                     archive TIMESTAMP,
                     PRIMARY KEY(id)
);

CREATE TABLE intramurudes.user_(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    username VARCHAR(127) NOT NULL,
                    password VARCHAR(127) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive TIMESTAMP,
                    PRIMARY KEY(id),
                    UNIQUE(username, archive)
);

CREATE TABLE intramurudes.log(
                    id INT GENERATED BY DEFAULT AS IDENTITY,
                    text TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    archive TIMESTAMP,
                    PRIMARY KEY(id)
);

CREATE TABLE intramurudes.match_team(
                    id_team INT,
                    id_match INT,
                    archive TIMESTAMP,
                    PRIMARY KEY(id_team, id_match),
                    FOREIGN KEY(id_team) REFERENCES intramurudes.team(id),
                    FOREIGN KEY(id_match) REFERENCES intramurudes.match_(id)
);



CREATE TABLE intramurudes.league_season(
                    id_league INT,
                    id_season INT,
                    archive TIMESTAMP,
                    PRIMARY KEY(id_league, id_season),
                    FOREIGN KEY(id_league) REFERENCES intramurudes.league(id),
                    FOREIGN KEY(id_season) REFERENCES intramurudes.season(id)
);

CREATE TABLE intramurudes.role_user(
                    id_role INT,
                    id_user INT,
                    archive TIMESTAMP,
                    PRIMARY KEY(id_role, id_user),
                    FOREIGN KEY(id_role) REFERENCES role(id),
                    FOREIGN KEY(id_user) REFERENCES user_(id)
);

CREATE TABLE intramurudes.stat_statement_sport(
                    id_sport INT,
                    id_stat_statement INT,
                    archive TIMESTAMP,
                    PRIMARY KEY(id_sport, id_stat_statement),
                    FOREIGN KEY(id_sport) REFERENCES sport(id),
                    FOREIGN KEY(id_stat_statement) REFERENCES stat_statement(id)
);


CREATE OR REPLACE VIEW intramurudes.v_match_teams AS
SELECT m.id AS id_match, m.date_match, m.begin_time, m.end_time,
       COUNT(mt.id_team) AS nb_teams,
       COALESCE(NULLIF(
                ARRAY_AGG(mt.id_team) FILTER (WHERE mt.id_team IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS list_teams,
       m.archive AS archive_match,
       m.place AS place,
       m.id_league AS id_league,
       m.id_season AS id_season
FROM intramurudes.match_ m
         LEFT JOIN intramurudes.match_team mt ON m.id = mt.id_match
GROUP BY m.id, m.date_match, m.begin_time, m.end_time
ORDER BY m.date_match, m.begin_time;



CREATE OR REPLACE VIEW intramurudes.v_player_team_league_sport
AS
SELECT p.id AS id_player, p.name AS name_player, p.last_name, p.number,
       t.id AS id_team, t.name AS name_team,
       l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date,
       s.id AS id_sport, s.name AS name_sport, s.nb_team_match,
       p.archive AS archive_player
FROM intramurudes.player p
         LEFT JOIN intramurudes.team t ON t.id = p.id_team
         LEFT JOIN intramurudes.league l ON l.id = t.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport
ORDER BY s.name, l.name, t.name, p.last_name;



CREATE OR REPLACE VIEW intramurudes.v_team_league_sport
AS
SELECT t.id AS id_team, t.name AS name_team,
       l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date,
       s.id AS id_sport, s.name AS name_sport, s.nb_team_match,
       t.archive AS archive_team
FROM intramurudes.team t
         LEFT JOIN intramurudes.league l ON l.id = t.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport
ORDER BY s.name, l.name, t.name;


CREATE OR REPLACE VIEW intramurudes.v_league_sport
AS
SELECT l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date, l.done,
       s.id AS id_sport, s.name AS name_soprt, s.nb_team_match,
       l.archive AS archive_league
FROM intramurudes.league AS l
         LEFT JOIN intramurudes.sport s ON l.id_sport = s.id
ORDER BY s.name, l.name;



CREATE OR REPLACE VIEW intramurudes.v_match_league_sport
AS
SELECT m.id AS match_id, m.date_match, m.begin_time, m.end_time,
       l.id AS id_league, l.name AS name_league, l.begin_date, l.end_date, l.done,
       s.id AS id_sport, s.name AS name_sport, s.nb_team_match,
       COALESCE(NULLIF(
                ARRAY_AGG(mt.id_team) FILTER (WHERE mt.id_team IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS list_teams,
       m.id_season AS id_season,
       m.place AS place,
       m.archive AS archive_match
FROM intramurudes.match_ m
         LEFT JOIN intramurudes.league l ON l.id = m.id_league
         LEFT JOIN intramurudes.sport s ON s.id = l.id_sport
         LEFT JOIN intramurudes.match_team mt ON mt.id_match = m.id
GROUP BY m.id, m.date_match, m.id, m.begin_time, m.end_time, l.id, l.name, l.begin_date, l.end_date, l.done, s.id, s.name, s.nb_team_match
ORDER BY s.name, l.name, l.begin_date;


CREATE OR REPLACE VIEW intramurudes.v_league
AS
SELECT l.id as id,
       l.name as name,
       l.begin_date as begin_date,
       l.end_date as end_date,
       l.done,
       l.id_sport,
       COALESCE(NULLIF(
                ARRAY_AGG(ls.id_season) FILTER (WHERE ls.id_season IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS id_seasons,
       l.archive AS archive_league
FROM intramurudes.league l
         LEFT JOIN intramurudes.league_season ls ON l.id = ls.id_league
GROUP BY l.id, l.name, l.begin_date, l.end_date, l.done, l.id_sport
ORDER BY l.id_sport, l.name;



CREATE OR REPLACE VIEW intramurudes.v_stat_statement
AS
SELECT ss.id as id,
       ss.statement as statement,
       ss.acronym as acronym,
       COALESCE(NULLIF(
                ARRAY_AGG(sss.id_sport) FILTER (WHERE sss.id_sport IS NOT NULL),
                '{}'
                ),
                ARRAY[-1]
       ) AS id_sports,
       ss.archive AS archive_stat_statement
FROM intramurudes.stat_statement ss
         LEFT JOIN intramurudes.stat_statement_sport sss ON ss.id = sss.id_stat_statement
GROUP BY ss.id, ss.statement, ss.acronym
ORDER BY ss.statement;



CREATE OR REPLACE VIEW intramurudes.v_player_stat
AS
SELECT ps.id AS id,
       ps.value_ AS value,
       CASE
           WHEN ps.id_match IS NULL THEN -1
           ELSE ps.id_match END
           AS id_match,
       ps.id_stat_statement AS id_stat_statement,
       vss.statement AS stat_statement,
       vss.acronym AS acronym_stat_statement,
       CASE
           WHEN ps.id_season IS NULL THEN -1
           ELSE ps.id_season END
           AS id_season,
       ps.id_player AS id_player,
       p.name AS name,
       p.last_name AS last_name,
       CASE
           WHEN m.id_league IS NULL THEN -1
           ELSE m.id_league END AS id_league,
       vptls.id_team AS id_team,
       vptls.id_league AS id_league_player,
       vptls.id_sport AS id_sport,
       ps.archive AS archive_player_stat
FROM intramurudes.player_stat ps
         LEFT JOIN intramurudes.match_ m ON m.id = ps.id_match
         LEFT JOIN intramurudes.player p ON p.id = ps.id_player
         LEFT JOIN intramurudes.v_player_team_league_sport vptls ON vptls.id_player = ps.id_player
         LEFT JOIN intramurudes.v_stat_statement vss ON vss.id = ps.id_stat_statement
ORDER BY vptls.name_sport, vptls.name_league, vptls.name_team, vptls.name_player, vss.statement;




CREATE OR REPLACE VIEW intramurudes.v_team_stat
AS
SELECT ts.id AS id,
       ts.value_ AS value,
       CASE
           WHEN ts.id_match IS NULL THEN -1
           ELSE ts.id_match END
           AS id_match,
       ts.id_stat_statement AS id_stat_statement,
       vss.statement AS stat_statement,
       vss.acronym AS acronym,
       CASE
           WHEN ts.id_season IS NULL THEN -1
           ELSE ts.id_season END
           AS id_season,
       CASE
           WHEN m.id_league IS NULL THEN -1
           ELSE m.id_league END AS id_league,
       vtls.id_team AS id_team,
       vtls.id_league AS id_league_team,
       vtls.id_sport AS id_sport,
       ts.archive AS archive_team_stat
FROM intramurudes.team_stat ts
         LEFT JOIN intramurudes.match_ m ON m.id = ts.id_match
         LEFT JOIN intramurudes.v_team_league_sport vtls ON vtls.id_team = ts.id_team
         LEFT JOIN intramurudes.v_stat_statement vss ON vss.id = ts.id_stat_statement
ORDER BY vtls.name_sport, vtls.name_league, vtls.name_team, vss.statement;


CREATE OR REPLACE VIEW intramurudes.v_all_stats
AS
SELECT
    'player' AS stat_type,
    vps.id AS id,
    vps.value AS value,
    vps.id_match AS id_match,
    vps.id_stat_statement AS id_stat_statement,
    vps.id_season AS id_season,
    vps.id_player AS id_owner,
    vps.id_league AS id_league,
    vps.id_sport AS id_sport,
    vps.archive_player_stat AS archive_stat
FROM intramurudes.v_player_stat vps
UNION
SELECT
    'team' AS stat_type,
    vts.id AS id,
    vts.value AS value,
    vts.id_match AS id_match,
    vts.id_stat_statement AS id_stat_statement,
    vts.id_season AS id_season,
    vts.id_team AS id_owner,
    vts.id_league AS id_league,
    vts.id_sport AS id_sport,
    vts.archive_team_stat AS archive_stat
FROM intramurudes.v_team_stat vts;







CREATE OR REPLACE FUNCTION intramurudes.get_season_from_league(id_league_get INT)
    RETURNS SETOF INT
    LANGUAGE SQL
AS $$
SELECT id_season FROM intramurudes.league_season ls
WHERE ls.id_league = id_league_get;
$$;

/**
  Vérifier la légalité de l'ajout du match
 */
CREATE OR REPLACE FUNCTION intramurudes.check_before_insert_match_()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
BEGIN
    IF (new.id_season IS NOT NULL
        AND
        new.id_season IN (SELECT intramurudes.get_season_from_league(new.id_league)))
    THEN
        RETURN new;
    ELSE
        RAISE 'Match is not in a season of the league';
    END IF;
END
$$;


CREATE TRIGGER trg_check_insert_match
    BEFORE INSERT ON intramurudes.match_
    FOR EACH ROW
EXECUTE function intramurudes.check_before_insert_match_();


/**
  Fonction qui donne le nombre de places restantes pour le match
 */
CREATE OR REPLACE FUNCTION intramurudes.get_place_left_match(id_new_match INT)
    RETURNS INT
    LANGUAGE SQL
AS $$
SELECT ((SELECT nb_team_match FROM intramurudes.v_league_sport vls
         WHERE id_league = (SELECT id_league FROM intramurudes.match_
                            WHERE id = id_new_match))
    -
        (SELECT COUNT(id_team) FROM intramurudes.match_team
         WHERE id_match = id_new_match));
$$;

/**
  Trigger pour s'assurer que toutes les équipes d'un match sont dans la même ligue
 */
CREATE OR REPLACE FUNCTION intramurudes.check_team_good_league(id_new_team INT, id_new_match INT)
    RETURNS BOOLEAN
    LANGUAGE SQL
AS $$
SELECT((SELECT m.id_league
        FROM intramurudes.match_ m
        WHERE m.id = id_new_match) IS NULL
    OR
       (SELECT vtls.id_league
        FROM intramurudes.v_team_league_sport vtls
        WHERE vtls.id_team = id_new_team) =
       ((SELECT m.id_league FROM intramurudes.match_ m
         WHERE m.id = id_new_match))
          );
$$;

/**
  Fonction pour vérifier chevauchement match
 */
CREATE OR REPLACE FUNCTION intramurudes.get_match_overlap(id_team_check INT, new_match_id INT)
    RETURNS SETOF INT
    LANGUAGE SQL
AS $$
SELECT id FROM intramurudes.match_ m
                   INNER JOIN intramurudes.match_team mt ON m.id = mt.id_match
WHERE m.date_match = (SELECT date_match FROM intramurudes.match_ WHERE id = new_match_id)
  AND
    (m.begin_time, m.end_time) OVERLAPS ((SELECT m2.begin_time FROM intramurudes.match_ m2 WHERE id = new_match_id),
                                         (SELECT m2.end_time FROM intramurudes.match_ m2 WHERE id = new_match_id))
  AND
    mt.id_team = id_team_check;
$$;

CREATE OR REPLACE FUNCTION intramurudes.check_before_insert_match_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF NOT EXISTS(SELECT intramurudes.get_match_overlap(new.id_team,
                                           new.id_match))
    THEN
        IF ((SELECT intramurudes.get_place_left_match(new.id_match)) > 0)
        THEN
            IF (SELECT intramurudes.check_team_good_league(new.id_team, new.id_match))
            THEN
                RETURN new;
            ELSE
                RAISE 'Team is not in the good league';
            END IF;
        ELSE
            RAISE 'Match is full';
        END IF;
    ELSE
        RAISE 'Match overlaps with another match of the team';
    END IF;
END;
$$;

CREATE TRIGGER trg_check_insert_match_team
    BEFORE INSERT ON intramurudes.match_team
    FOR EACH ROW
EXECUTE function intramurudes.check_before_insert_match_team();


CREATE OR REPLACE FUNCTION intramurudes.insert_v_match_teams()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
DECLARE
    id_new_match INT;
BEGIN
    IF(new.place IS NULL)
    THEN
        new.place = '--';
    END IF;
    INSERT INTO intramurudes.match_ (date_match, begin_time, end_time, id_league, id_season, place)
    VALUES(new.date_match, new.begin_time, new.end_time, new.id_league, new.id_season, new.place);
    id_new_match = (SELECT last_value FROM intramurudes.match__id_seq);
    IF (SELECT ARRAY_LENGTH(new.list_teams, 1)) > 0
    THEN
        INSERT INTO intramurudes.match_team (id_team, id_match)
        VALUES (UNNEST(new.list_teams), id_new_match);
    END IF;
    RETURN NULL;
END
$$;


CREATE TRIGGER trg_insert_v_stat_statement
    INSTEAD OF INSERT ON intramurudes.v_match_teams
    FOR EACH ROW
EXECUTE function intramurudes.insert_v_match_teams();


--Fonctions pour insérer dans la vue des stat_statement et faire le lien avec le sport
CREATE OR REPLACE FUNCTION intramurudes.insert_v_stat_statement()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
DECLARE
    id_sport_add int;
    id_stat int;
BEGIN
    IF (new.statement NOT IN (SELECT statement FROM intramurudes.v_stat_statement))
    THEN
        INSERT INTO intramurudes.stat_statement(statement, acronym)
        VALUES (new.statement, new.acronym);
    END IF;
    id_stat = (SELECT id FROM intramurudes.stat_statement
               WHERE statement = new.statement);
    FOREACH id_sport_add IN ARRAY new.id_sports
        LOOP
            IF(NOT id_sport_add = ANY (SELECT unnest(id_sports) FROM intramurudes.v_stat_statement
                                       WHERE id = id_stat))
            THEN
                INSERT INTO intramurudes.stat_statement_sport(id_sport, id_stat_statement)
                VALUES (id_sport_add, id_stat);
            END IF;

        END LOOP;
    RETURN new;
END
$$;


CREATE TRIGGER trg_insert_v_stat_statement
    INSTEAD OF INSERT ON intramurudes.v_stat_statement
    FOR EACH ROW
EXECUTE function intramurudes.insert_v_stat_statement();




--Méthode pour mettre la saison selon le match de la stat s'il y a un match
CREATE OR REPLACE FUNCTION intramurudes.create_stat()
    RETURNS TRIGGER
    LANGUAGE PLPGSQL
AS $$
DECLARE
    stat_type1 varchar;
BEGIN
    stat_type1 = TG_ARGV[0];
    --Vérifier si la stat existe déjà, si c'est le cas, archiver l'ancienne valeur
    IF( stat_type1 = 'team')
    THEN
        DELETE FROM intramurudes.v_all_stats vas
        WHERE vas.stat_type = stat_type1 AND
            vas.id_match = new.id_match AND
            vas.id_stat_statement = new.id_stat_statement AND
            vas.id_season = new.id_season AND
            vas.id_owner = new.id_team AND
            vas.archive_stat IS NULL;
    ELSE IF (stat_type1 = 'player')
    THEN
        DELETE FROM intramurudes.v_all_stats vas
        WHERE vas.stat_type = stat_type1 AND
            vas.id_match = new.id_match AND
            vas.id_stat_statement = new.id_stat_statement AND
            vas.id_season = new.id_season AND
            vas.id_owner = new.id_player AND
            vas.archive_stat IS NULL;
    END IF;
    END IF;

    --Mettre la bonne saison
    IF new.id_match IS NOT NULL
    THEN
        new.id_season = (SELECT id_season FROM intramurudes.match_
                         WHERE id = new.id_match);
    END IF;
    RETURN new;
END;
$$;

CREATE TRIGGER trg_create_stat
    BEFORE INSERT ON intramurudes.player_stat
    FOR EACH ROW
EXECUTE function intramurudes.create_stat('player');

CREATE TRIGGER trg_create_stat
    BEFORE INSERT ON intramurudes.team_stat
    FOR EACH ROW
EXECUTE function intramurudes.create_stat('team');









CREATE OR REPLACE FUNCTION intramurudes.delete_v_all_stats()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    IF(old.stat_type = 'team')
    THEN
        DELETE FROM intramurudes.team_stat ts
        WHERE ts.id_season = old.id_season AND
            ts.id_match = old.id_match AND
            ts.id_stat_statement = old.id_stat_statement AND
            ts.id_team = old.id_owner;
    END IF;

    IF(old.stat_type = 'player')
    THEN
        DELETE FROM intramurudes.player_stat ps
        WHERE ps.id_season = old.id_season AND
            ps.id_match = old.id_match AND
            ps.id_stat_statement = old.id_stat_statement AND
            ps.id_player = old.id_owner;
    END IF;
    RETURN NULL;
END;
$$;


CREATE TRIGGER trg_delete_v_all_stats
    INSTEAD OF DELETE ON intramurudes.v_all_stats
    FOR EACH ROW
EXECUTE function intramurudes.delete_v_all_stats();




--Trigger pour les deletes
CREATE OR REPLACE FUNCTION intramurudes.instead_delete_sport()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.sport s
    SET archive = NOW()
    WHERE s.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.league
    WHERE id_sport = old.id;

    DELETE FROM intramurudes.stat_statement_sport
    WHERE id_sport = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_sport
    BEFORE DELETE ON intramurudes.sport
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_sport();


CREATE OR REPLACE FUNCTION intramurudes.instead_delete_league()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.league l
    SET archive = NOW()
    WHERE l.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.team
    WHERE id_league = old.id;

    DELETE FROM intramurudes.league_season
    WHERE id_league = old.id;

    DELETE FROM intramurudes.match_
    WHERE id_league = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_league
    BEFORE DELETE ON intramurudes.league
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_league();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.team t
    SET archive = NOW()
    WHERE t.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.player p
    WHERE p.id_team = old.id;

    DELETE FROM intramurudes.match_team
    WHERE id_team = old.id;

    DELETE FROM intramurudes.team_stat
    WHERE id_team = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_team
    BEFORE DELETE ON intramurudes.team
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_team();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_player()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.player p
    SET archive = NOW()
    WHERE p.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.player_stat ps
    WHERE ps.id_player = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_player
    BEFORE DELETE ON intramurudes.player
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_player();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_league_season()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.league_season ls
    SET archive = NOW()
    WHERE ls.id_league = old.id_league AND ls.id_season = old.id_season AND archive IS NULL;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_league_season
    BEFORE DELETE ON intramurudes.league_season
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_league_season();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_match()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.match_ m
    SET archive = NOW()
    WHERE m.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.match_team
    WHERE id_match = old.id;

    DELETE FROM intramurudes.player_stat
    WHERE id_match = old.id;

    DELETE FROM intramurudes.team_stat
    WHERE id_match = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_match
    BEFORE DELETE ON intramurudes.match_
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_match();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_match_team()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.match_team mt
    SET archive = NOW()
    WHERE mt.id_match = old.id_match AND mt.id_team = old.id_team AND archive IS NULL;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_match_team
    BEFORE DELETE ON intramurudes.match_team
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_match_team();


CREATE OR REPLACE FUNCTION intramurudes.instead_delete_player_stat()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    UPDATE intramurudes.player_stat ps
    SET archive = NOW()
    WHERE ps.id = old.id AND archive IS NULL;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_player_stat
    BEFORE DELETE
    ON intramurudes.player_stat
    FOR EACH ROW
EXECUTE FUNCTION intramurudes.instead_delete_player_stat();


CREATE OR REPLACE FUNCTION intramurudes.instead_delete_season()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.season s
    SET archive = NOW()
    WHERE s.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.player_stat
    WHERE id_season = old.id;

    DELETE FROM intramurudes.team_stat
    WHERE id_season = old.id;

    DELETE FROM intramurudes.league_season
    WHERE id_season = old.id;

    DELETE FROM intramurudes.match_
    WHERE id_season = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_season
    BEFORE DELETE ON intramurudes.season
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_season();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_stat_statement()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.stat_statement s
    SET archive = NOW()
    WHERE s.id = old.id AND archive IS NULL;

    DELETE FROM intramurudes.stat_statement_sport
    WHERE id_stat_statement = old.id;

    DELETE FROM intramurudes.team_stat
    WHERE id_stat_statement = old.id;

    DELETE FROM intramurudes.player_stat
    WHERE id_stat_statement = old.id;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_stat_statement
    BEFORE DELETE ON intramurudes.stat_statement
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_stat_statement();



CREATE OR REPLACE FUNCTION intramurudes.instead_delete_stat_statement_sport()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.stat_statement_sport s
    SET archive = NOW()
    WHERE s.id_stat_statement = old.id_stat_statement AND s.id_sport = old.id_sport AND archive IS NULL;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_stat_statement_sport
    BEFORE DELETE ON intramurudes.stat_statement_sport
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_stat_statement_sport();




CREATE OR REPLACE FUNCTION intramurudes.instead_delete_team_stat()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE intramurudes.team_stat ts
    SET archive = NOW()
    WHERE ts.id = old.id AND archive IS NULL;

    RETURN NULL;
END;
$$;

CREATE TRIGGER trg_delete_team_stat
    BEFORE DELETE ON intramurudes.team_stat
    FOR EACH ROW
EXECUTE function intramurudes.instead_delete_team_stat();
